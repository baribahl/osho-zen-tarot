---
import BaseLayout from "../layouts/BaseLayout.astro";
import CardStack from "../components/CardStack.astro";
import CardCarousel from "../components/CardCarousel.astro";
import "../styles/overlay.css";

// Les cartes seront chargées côté client via le script
---

<BaseLayout title="Tirer une carte - BaribOsho v1">
  <div class="hero-section">
    <div class="hero-container">
      <div class="hero-left">
        <h1 class="hero-title">Osho Zen Tarot</h1>
        <p class="hero-subtitle">
          Découvrez la sagesse du moment présent à travers les 79 cartes du
          Tarot Zen. Une approche unique pour explorer votre réalité intérieure.
        </p>
        <button id="drawCardBtn" class="draw-button">
          <span class="btn-text">Tirer une carte</span>
          <span class="material-symbols-outlined btn-icon">playing_cards</span>
        </button>
      </div>
      <div class="hero-right">
        <CardStack />
      </div>
    </div>
  </div>

  <!-- Discovery Section -->
  <section class="discovery-section">
    <div class="discovery-container">
      <a href="#" id="drawCardLink" class="discovery-tile">
        <span class="material-symbols-outlined tile-icon">auto_awesome</span>
        <h3 class="tile-title">Tirage du Moment</h3>
        <p class="tile-desc">
          Recevez un message immédiat pour éclairer votre situation actuelle.
        </p>
      </a>
      <a href="/cartes" class="discovery-tile">
        <span class="material-symbols-outlined tile-icon">grid_view</span>
        <h3 class="tile-title">Explorer la Galerie</h3>
        <p class="tile-desc">
          Parcourez les 79 cartes et découvrez leurs significations profondes.
        </p>
      </a>
      <a href="/a-propos" class="discovery-tile">
        <span class="material-symbols-outlined tile-icon">info</span>
        <h3 class="tile-title">À propos</h3>
        <p class="tile-desc">
          Pourquoi ce site existe, et ce qu'il y a dans les coulisses.
        </p>
      </a>
    </div>
  </section>

  <!-- Card Carousel -->
  <CardCarousel />

  <!-- Card Reveal Overlay -->
  <div id="cardRevealOverlay" class="card-reveal-overlay">
    <button id="closeReveal" class="close-reveal-btn" aria-label="Fermer">
      <span class="material-symbols-outlined">close</span>
    </button>
    <div id="revealContent" class="reveal-content">
      <!-- Content will be dynamically injected -->
    </div>
  </div>
</BaseLayout>

<style>
  /* === Hero Section === */
  .hero-section {
    min-height: 75vh;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: var(--space-3xl) var(--space-lg);
    position: relative;
    overflow: hidden;
  }

  .hero-container {
    max-width: 1400px;
    width: 100%;
    display: grid;
    grid-template-columns: 60% 40%;
    gap: var(--space-3xl);
    align-items: center;
  }

  .hero-left {
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
  }

  .hero-title {
    font-family: var(--font-heading);
    font-size: clamp(3rem, 5vw, 4.5rem);
    font-weight: 700;
    background: linear-gradient(
      135deg,
      var(--color-accent-gold),
      var(--color-accent-amber)
    );
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin: 0;
    line-height: 1.1;
  }

  .hero-subtitle {
    font-size: clamp(1.125rem, 1.5vw, 1.375rem);
    color: var(--color-text-secondary);
    line-height: 1.7;
    max-width: 560px;
    margin: 0;
  }

  .draw-button {
    display: inline-flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-xl);
    background: var(--color-accent-gold);
    color: #0f1725;
    border: none;
    border-radius: var(--border-radius-md);
    font-size: 1.125rem;
    font-weight: 700;
    cursor: pointer;
    transition: all var(--transition-normal);
    box-shadow: var(--shadow-mystic);
    width: fit-content;
  }

  .draw-button:hover {
    background: var(--color-accent-amber);
    transform: translateY(-2px);
    box-shadow: 0 12px 40px -12px rgba(212, 175, 55, 0.5);
  }

  .draw-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .hero-right {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  /* === Discovery Section === */
  .discovery-section {
    padding: var(--space-3xl) var(--space-lg);
    background: rgba(15, 23, 37, 0.4);
  }

  .discovery-container {
    max-width: 1400px;
    margin: 0 auto;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: var(--space-xl);
  }

  .discovery-tile {
    background: rgba(26, 34, 50, 0.6);
    border: var(--border-gold-thin);
    border-radius: var(--border-radius-lg);
    padding: var(--space-xl);
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    transition: all var(--transition-normal);
    cursor: pointer;
    text-decoration: none;
    color: inherit;
  }

  .discovery-tile:hover {
    border-color: var(--color-accent-gold);
    background: rgba(26, 34, 50, 0.8);
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(212, 175, 55, 0.2);
  }

  .tile-icon {
    font-size: 2.5rem;
    color: var(--color-accent-gold);
  }

  .tile-title {
    font-family: var(--font-heading);
    font-size: 1.5rem;
    margin: 0;
    color: var(--color-text-primary);
  }

  .tile-desc {
    font-size: var(--text-base);
    color: var(--color-text-secondary);
    line-height: 1.6;
    margin: 0;
  }

  /* ===== DRAW ANIMATION BACKDROP ===== */
  :global(.draw-backdrop) {
    position: fixed;
    inset: 0;
    background: rgba(10, 15, 25, 0.85);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    z-index: 999;
    opacity: 0;
    transition: opacity 1s ease;
    pointer-events: none;
  }

  :global(.draw-backdrop.active) {
    opacity: 1;
    pointer-events: auto;
  }

  /* ===== CARD INFO PANEL (appears after reveal) ===== */
  :global(.card-info-panel) {
    position: fixed;
    /* Center vertically, position to the right of center */
    top: 50%;
    left: calc(50% + 12vw);
    transform: translateY(-50%);
    max-width: 380px;
    z-index: 1001;
    opacity: 0;
    transition: opacity 1.2s ease, transform 1.2s ease;
    pointer-events: none;
  }

  :global(.card-info-panel.visible) {
    opacity: 1;
    pointer-events: auto;
  }

  :global(.card-info-panel .card-name) {
    font-family: var(--font-heading);
    font-size: clamp(2rem, 4vw, 3rem);
    color: var(--color-accent-gold);
    margin: 0 0 var(--space-md) 0;
  }

  :global(.card-info-panel .card-meta) {
    font-size: var(--text-base);
    color: var(--color-text-secondary);
    margin-bottom: var(--space-lg);
    text-transform: uppercase;
    letter-spacing: 2px;
  }

  :global(.card-info-panel .card-action) {
    display: inline-flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-md) var(--space-xl);
    background: var(--color-accent-gold);
    color: #0f1725;
    border: none;
    border-radius: var(--border-radius-md);
    font-size: var(--text-base);
    font-weight: 700;
    cursor: pointer;
    text-decoration: none;
    transition: all var(--transition-normal);
  }

  :global(.card-info-panel .card-action:hover) {
    background: var(--color-accent-amber);
    transform: translateY(-2px);
  }

  :global(.close-draw-btn) {
    position: fixed;
    top: var(--space-lg);
    right: var(--space-lg);
    z-index: 1002;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--color-text-primary);
    opacity: 0;
    transition: opacity 0.5s ease, background 0.3s ease;
    pointer-events: none;
  }

  :global(.close-draw-btn.visible) {
    opacity: 1;
    pointer-events: auto;
  }

  :global(.close-draw-btn:hover) {
    background: rgba(255, 255, 255, 0.2);
  }

  /* Responsive for card info panel */
  @media (max-width: 1024px) {
    :global(.card-info-panel) {
      left: calc(50% + 10vw);
      max-width: 320px;
    }
  }

  @media (max-width: 768px) {
    :global(.card-info-panel) {
      position: fixed;
      top: auto;
      left: 50%;
      bottom: 8%;
      transform: translateX(-50%);
      text-align: center;
      max-width: 90%;
    }
    
    :global(.card-info-panel .card-name) {
      font-size: 1.75rem;
    }
    
    :global(.card-info-panel .card-meta) {
      font-size: 0.875rem;
      margin-bottom: var(--space-md);
    }
  }
</style>

<script>
  import cardsDataImport from "../data/osho_cards.json";

  const cardsData = cardsDataImport;

  const drawBtn = document.getElementById("drawCardBtn");
  const drawLink = document.getElementById("drawCardLink");
  const cardStackWrapper = document.getElementById("cardStackWrapper");
  const cardStack = document.getElementById("cardStack");

  // We'll create these dynamically
  let backdrop: HTMLElement | null = null;
  let infoPanel: HTMLElement | null = null;
  let closeBtn: HTMLElement | null = null;
  let selectedCard: HTMLElement | null = null;

  if ((drawBtn || drawLink) && cardStack && cardStackWrapper) {
    
    const handleDraw = async (e: Event) => {
      if (e) e.preventDefault();

      if (cardsData.length === 0) {
        console.error("Les cartes ne sont pas encore chargées");
        return;
      }

      // Disable button
      if (drawBtn) drawBtn.setAttribute("disabled", "true");

      // Pick random card data
      const randomCard = cardsData[Math.floor(Math.random() * cardsData.length)];
      
      // Pick random card from the visual deck (0-6)
      const selectedIndex = Math.floor(Math.random() * 7);
      selectedCard = cardStack.querySelector(`.stack-card[data-index="${selectedIndex}"]`) as HTMLElement;
      
      // Preload image BEFORE starting animation
      const cardImage = selectedCard.querySelector('.card-image') as HTMLImageElement;
      const imageLoaded = new Promise<void>((resolve) => {
        if (cardImage) {
          cardImage.onload = () => resolve();
          cardImage.onerror = () => resolve(); // Continue even if error
          cardImage.src = randomCard.image_url_online;
          cardImage.alt = randomCard.name;
          // If already cached, resolve immediately
          if (cardImage.complete) resolve();
        } else {
          resolve();
        }
      });

      // ========== PHASE 0: CREATE BACKDROP & CENTER DECK ==========
      // Create backdrop
      backdrop = document.createElement("div");
      backdrop.className = "draw-backdrop";
      document.body.appendChild(backdrop);

      // Create close button
      closeBtn = document.createElement("button");
      closeBtn.className = "close-draw-btn";
      closeBtn.innerHTML = '<span class="material-symbols-outlined">close</span>';
      closeBtn.setAttribute("aria-label", "Fermer");
      document.body.appendChild(closeBtn);

      // Stop float idle animation smoothly
      cardStack.style.animation = 'none';

      // === SMOOTH CENTERING: Capture current position first ===
      const rect = cardStackWrapper.getBoundingClientRect();
      const startTop = rect.top;
      const startLeft = rect.left;
      
      // Set the starting position as inline styles BEFORE adding centering class
      cardStackWrapper.style.top = `${startTop}px`;
      cardStackWrapper.style.left = `${startLeft}px`;
      cardStackWrapper.style.transform = 'none';
      
      // Now add centering class (which sets position: fixed)
      cardStackWrapper.classList.add("centering");
      
      // Force reflow to ensure the starting position is applied
      void cardStackWrapper.offsetHeight;
      
      // Activate backdrop (blur/darken page)
      await new Promise((resolve) => setTimeout(resolve, 50));
      backdrop.classList.add("active");

      // Now animate to center position
      const targetTop = window.innerHeight * 0.50; // Center vertically
      const targetLeft = window.innerWidth / 2;
      cardStackWrapper.style.top = `${targetTop}px`;
      cardStackWrapper.style.left = `${targetLeft}px`;
      cardStackWrapper.style.transform = 'translate(-50%, -50%) scale(1.1)';
      
      // Wait for centering transition
      await new Promise((resolve) => setTimeout(resolve, 900));

      // ========== PHASE 1: WIGGLE (2.5 seconds) ==========
      cardStack.classList.add("wiggling");
      await new Promise((resolve) => setTimeout(resolve, 2500));

      // ========== PHASE 2: SPREAD (slow, wide fan) ==========
      cardStack.classList.remove("wiggling");
      
      // Small pause to let wiggle animation stop cleanly
      await new Promise((resolve) => setTimeout(resolve, 100));
      
      cardStack.classList.add("spread");
      
      // Wait for spread animation (1.8s transition) + pause
      await new Promise((resolve) => setTimeout(resolve, 2500));

      // ========== PHASE 2.5: PRE-SELECTION GLOW ==========
      // Add subtle glow to selected card BEFORE it emerges
      selectedCard.classList.add("pre-selected");
      await new Promise((resolve) => setTimeout(resolve, 1200));

      // ========== PHASE 3: SELECTED CARD EMERGES ==========
      selectedCard.classList.remove("pre-selected");
      selectedCard.classList.add("emerging");
      
      await new Promise((resolve) => setTimeout(resolve, 1200));

      // Fade other cards
      cardStack.classList.add("has-selection");
      await new Promise((resolve) => setTimeout(resolve, 800));

      // ========== PHASE 4: RISING (3D toward viewer) ==========
      selectedCard.classList.remove("emerging");
      selectedCard.classList.add("rising");
      
      await new Promise((resolve) => setTimeout(resolve, 1200));

      // ========== PHASE 5: FLIP - Wait for image first ==========
      await imageLoaded; // Ensure image is loaded before flip
      
      selectedCard.classList.remove("rising");
      selectedCard.classList.add("flipping");
      
      // Wait for flip animation (1s transform)
      await new Promise((resolve) => setTimeout(resolve, 1400));

      // ========== PHASE 6: REVEALED - slide left, show info ==========
      selectedCard.classList.remove("flipping");
      selectedCard.classList.add("revealed");
      cardStack.classList.add("final-reveal");

      // Show close button
      closeBtn.classList.add("visible");

      // Create and show info panel
      const familyEmojis: Record<string, string> = {
        "Arc-en-ciel": "🌈",
        "Feu": "🔥",
        "Eau": "💧",
        "Nuages": "☁️",
      };

      let metaText = "";
      if (randomCard.arcana_type === "major") {
        metaText = randomCard.arcana;
      } else {
        const familyEmoji = randomCard.arcana_family ? familyEmojis[randomCard.arcana_family] || "" : "";
        const positionWithEmoji = randomCard.arcana_position 
          ? `${randomCard.arcana_position} ${familyEmoji}`.trim()
          : "";
        metaText = positionWithEmoji 
          ? `Arcane Mineure • ${positionWithEmoji}`
          : "Arcane Mineure";
      }

      infoPanel = document.createElement("div");
      infoPanel.className = "card-info-panel";
      infoPanel.innerHTML = `
        <h2 class="card-name">${randomCard.name}</h2>
        <p class="card-meta">${metaText}</p>
        <a href="/carte/${randomCard.card_number}" class="card-action">
          <span class="material-symbols-outlined">visibility</span>
          Voir la fiche complète
        </a>
      `;
      document.body.appendChild(infoPanel);

      // Fade in info panel after card slides
      await new Promise((resolve) => setTimeout(resolve, 800));
      infoPanel.classList.add("visible");
    };

    const closeDraw = () => {
      // Remove all dynamic elements
      if (backdrop) {
        backdrop.classList.remove("active");
        setTimeout(() => backdrop?.remove(), 500);
      }
      if (infoPanel) {
        infoPanel.classList.remove("visible");
        setTimeout(() => infoPanel?.remove(), 500);
      }
      if (closeBtn) {
        closeBtn.classList.remove("visible");
        setTimeout(() => closeBtn?.remove(), 500);
      }

      // Reset card stack
      cardStackWrapper.classList.remove("centering");
      cardStack.classList.remove("wiggling", "spread", "has-selection", "final-reveal");
      
      // Clear inline styles used for smooth centering
      cardStackWrapper.style.top = '';
      cardStackWrapper.style.left = '';
      cardStackWrapper.style.transform = '';
      
      // Restore float animation
      cardStack.style.animation = '';
      
      // Reset all cards
      cardStack.querySelectorAll(".stack-card").forEach((card) => {
        card.classList.remove("pre-selected", "emerging", "rising", "flipping", "revealed");
        // Clear the image source
        const img = card.querySelector('.card-image') as HTMLImageElement;
        if (img) {
          img.src = '';
          img.alt = '';
        }
      });

      // Re-enable button
      if (drawBtn) drawBtn.removeAttribute("disabled");

      // Clear references
      backdrop = null;
      infoPanel = null;
      closeBtn = null;
      selectedCard = null;
    };

    // Event listeners
    if (drawBtn) drawBtn.addEventListener("click", handleDraw);
    if (drawLink) drawLink.addEventListener("click", handleDraw);

    // Close on button click, backdrop click, or Escape
    document.addEventListener("click", (e) => {
      const target = e.target as HTMLElement;
      
      // Close button clicked
      if (closeBtn && (target === closeBtn || target.closest(".close-draw-btn"))) {
        closeDraw();
        return;
      }
      
      // Backdrop clicked (but not the card or info panel)
      if (backdrop && target === backdrop) {
        closeDraw();
        return;
      }
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && backdrop?.classList.contains("active")) {
        closeDraw();
      }
    });
  }

  // Parallax
  const heroSection = document.querySelector(".hero-section") as HTMLElement;
  if (heroSection) {
    window.addEventListener("scroll", () => {
      const scrolled = window.pageYOffset;
      if (scrolled < heroSection.offsetHeight) {
        heroSection.style.setProperty("--parallax-offset-before", `${scrolled * 0.5}px`);
        heroSection.style.setProperty("--parallax-offset-after", `${scrolled * 0.3}px`);
      }
    });
  }
</script>
